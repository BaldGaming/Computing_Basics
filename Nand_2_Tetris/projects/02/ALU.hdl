CHIP ALU
{
    IN
        x[16], y[16],  // 16-bit inputs        
        zx, // zero the x input?
        nx, // negate the x input?
        zy, // zero the y input?
        ny, // negate the y input?
        f,  // compute (out = x + y) or (out = x & y)?
        no; // negate the out output?

    OUT 
        out[16], // 16-bit output
        zr,      // (out == 0, 1, 0)
        ng;      // (out < 0,  1, 0)

    PARTS:
        // zx: Mux16 - if false | Not16 - if true.
        Mux16 (a=x ,b=false, sel=zx, out=x-zx);
        Not16 (in=x-zx, out=x-zx-not);
        
        // nx: Mux16 - Accepts x-zx / x-zx-not.
        Mux16 (a=x-zx, b=x-zx-not, sel=nx, out=x-nx);

        // zy: Mux16 - if false, Not16 - if true.
        Mux16 (a=y ,b=false, sel=zy, out=y-zy);
        Not16 (in=y-zy, out=y-zy-not);

        // nx: Mux16 - Accepts y-zy / y-zy-not.
        Mux16 (a=y-zy, b=y-zy-not, sel=ny, out=y-ny);

        // f: Or16 - if f true | Add16 - if f false.
        Add16 (a=x-nx, b=y-ny, out=f-add);
        And16 (a=x-nx, b=y-ny, out=f-and);
        Mux16 (a=f-and, b=f-add, sel=f, out=f-out);

        // no: Not16 - if true.
        Not16 (in=f-out, out=no-out);

        // ng: Mux16 - creates flags ng output.
        Mux16 (a=f-out, b=no-out, sel=no, out[0..7]=no-out-left, out[8..15]=no-out-right, out[15]=ng, out=out);

        // zr: Uses flags to determain output.
        Or8Way (in=no-out-left, out=flag0);
        Or8Way (in=no-out-right, out=flag1);
        Or (a=flag0, b=flag1, out=flag);
        Not (in=flag, out=zr);
}